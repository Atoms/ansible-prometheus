#!/bin/bash

# The "promrun" script runs and monitors a specified command
#
# 'sponge' isn't used as a temporary file is required by the GNU 'time'
# command

# Author: MesaGuy (https://github.com/mesaguy)
# Source: https://github.com/mesaguy/ansible-prometheus/tree/master/templates/promrun.sh.j2
# Tests: https://github.com/mesaguy/ansible-prometheus/tree/master/tests/inspec/promrun
# License: MIT
# Version: 0.1 (2020-01-09)

if [ "{{ prometheus_promrun_ansible_managed }}" == "True" ] ; then
    HAS_TIME="{{ prometheus_time_is_installed }}"
    GNU_TIME_COMMAND="{{ prometheus_gnu_time_path }}"
    # This section is only utilized if script is installed via Ansible
    TEXTFILE_DIRECTORY="{{ prometheus_node_exporter_textfiles_directory }}"
else
    GNU_TIME_COMMAND=/usr/bin/time
    if which time > /dev/null 2>&1 ; then
        HAS_TIME=True
    fi
    TEXTFILE_DIRECTORY="/etc/prometheus/node_exporter_textfiles"
fi

RE_METRIC_NAME="^[a-zA-Z_:][a-zA-Z0-9_:]*$"

function usage () {
    echo "USAGE"
    echo
    exit 1
}

# read the option and store in the variable, $option
while getopts "Dhln::s:v" option; do
    case ${option} in
        d)
	        DESCRIPTION="$OPTARG"
            ;;
        D)
	        DRYRUN=1
            ;;
        h)
	        usage
            ;;
        l)
            LABELS="$LABELS,$(echo $OPTARG | cut -d '=' -f 1)=\"$(echo $OPTARG | cut -d "=" -f 2-)\""
            ;;
        n)
	        NAME="${OPTARG}"
            ;;
        s)
	        SETUP_USER="$OPTARG"
            ;;
        v)
	        VERBOSE=1
            ;;
        \?)
	        usage
            ;;
    esac
done

if [ -z "$NAME" ] ; then
    echo "NAME (-n) must be defined" >&2
    exit 2
fi

if [ -z "$HAS_TIME" ] ; then
    echo "'time' command must be in PATH" >&2
    exit 2
fi

# Set USER variable if undefined
if [ -z "$USER" ] ; then
    USER=$(whoami)
fi

LABELS="user=\"${USER}\""
TEXTFILE_PATH="${TEXTFILE_DIRECTORY}/promrun_${NAME}.prom"
NAME="promrun_${NAME}"

if [ -n "$SETUP_USER" ] ; then
    if [ "$USER" != "root" ] && [ -z "$DRYRUN" ]; then
        echo "Command must be run as root" >&2
        exit 2
    fi
    if ! id $SETUP_USER > /dev/null 2>&1 ; then
        echo "No such user $SETUP_USER" >&2
        exit 2
    fi
    if [ -n "$DRYRUN" ] ; then
        echo "[DRYRUN] touch \"$TEXTFILE_PATH\" \"${TEXTFILE_PATH}.tmp\" && chown $SETUP_USER \"$TEXTFILE_PATH\" \"${TEXTFILE_PATH}.tmp\""
    else
        touch "$TEXTFILE_PATH" "${TEXTFILE_PATH}.tmp" && chown $SETUP_USER "$TEXTFILE_PATH" "${TEXTFILE_PATH}.tmp"
    fi
    exit 0
fi

if [ -n "$DESCRIPTION" ] ; then
    LABELS="$LABELS,description=\"$DESCRIPTION\""
fi

if [ -n "$DRYRUN" ] ; then
    echo "Dry-run is not supported outside of the setup (-s) argument" >&2
    exit 2
fi

if [[ ! $NAME =~ $RE_METRIC_NAME ]] ; then
    echo "Metric name \"$NAME\" must match regex: $RE_METRIC_NAME" >&2
    exit 2
fi

printf "# HELP ${NAME}_starttime Start time in Unix time with microseconds.
# TYPE ${NAME}_starttime gauge
${NAME}_starttime{$LABELS} $(date +%s%3N)\n" > ${TEXTFILE_PATH}.tmp
TIME_FORMAT="# HELP ${NAME}_cpu_kernel_mode_seconds Total number of CPU-seconds that the process spent in kernel mode.
# TYPE ${NAME}_cpu_kernel_mode_seconds gauge
${NAME}_cpu_kernel_mode_seconds{$LABELS} %S
# HELP ${NAME}_elapsed_seconds Elapsed real time (in seconds).
# TYPE ${NAME}_elapsed_seconds gauge
${NAME}_elapsed_seconds{$LABELS} %e
# HELP ${NAME}_cpu_user_mode_seconds Total number of CPU-seconds that the process spent in user mode.
# TYPE ${NAME}_cpu_user_mode_seconds gauge
${NAME}_cpu_user_mode_seconds{$LABELS} %U
# HELP ${NAME}_max_resident_memory_kb Maximum resident set size of the process during its lifetime, in Kbytes.
# TYPE ${NAME}_max_resident_memory_kb gauge
${NAME}_max_resident_memory_kb{$LABELS} %M
# HELP ${NAME}_avg_total_memory_kb Average total (data+stack+text) memory use of the process, in Kbytes.
# TYPE ${NAME}_avg_total_memory_kb gauge
${NAME}_avg_total_memory_kb{$LABELS} %K
# HELP ${NAME}_swapped_from_main_memory_count Number of times the process was swapped out of main memory.
# TYPE ${NAME}_swapped_from_main_memory_count gauge
${NAME}_swapped_from_main_memory_count{$LABELS} %W
# HELP ${NAME}_signals_delivered_to_process_count Number of signals delivered to the process.
# TYPE ${NAME}_signals_delivered_to_process_count gauge
${NAME}_signals_delivered_to_process_count{$LABELS} %k
# HELP ${NAME}_context_switch_count_involuntary_count Number of times the process was context-switched involuntarily (because the time slice expired).
# TYPE ${NAME}_context_switch_count_involuntary_count gauge
${NAME}_context_switch_count_involuntary_count{$LABELS} %c
# HELP ${NAME}_context_switch_count_voluntary_count Number of waits: times that the program was context-switched voluntarily, for instance while waiting for an I/O operation to complete.
# TYPE ${NAME}_context_switch_count_voluntary_count gauge
${NAME}_context_switch_count_voluntary_count{$LABELS} %w
# HELP ${NAME}_filesystem_inputs_count Number of filesystem inputs by the process.
# TYPE ${NAME}_filesystem_inputs_count gauge
${NAME}_filesystem_inputs_count{$LABELS} %I
# HELP ${NAME}_filesystem_outputs_count Number of filesystem outputs by the process.
# TYPE ${NAME}_filesystem_outputs_count gauge
${NAME}_filesystem_outputs_count{$LABELS} %O
# HELP ${NAME}_socket_messages_received_count Number of socket messages received by the process.
# TYPE ${NAME}_socket_messages_received_count gauge
${NAME}_socket_messages_received_count{$LABELS} %r
# HELP ${NAME}_socket_messages_sent_count Number of socket messages sent by the process.
# TYPE ${NAME}_socket_messages_sent_count gauge
${NAME}_socket_messages_sent_count{$LABELS} %s
# HELP ${NAME}_exit_status Exit status of the command.
# TYPE ${NAME}_exit_status gauge
${NAME}_exit_status{$LABELS} %x
# HELP ${NAME}_process_avg_size_resident_set_kb Average resident set size of the process, in Kbytes.
# TYPE ${NAME}_process_avg_size_resident_set_kb gauge
${NAME}_process_avg_size_resident_set_kb{$LABELS} %t
# HELP ${NAME}_process_avg_size_unshared_data_area_kb Average size of the process's unshared data area, in Kbytes.
# TYPE ${NAME}_process_avg_size_unshared_data_area_kb gauge
${NAME}_process_avg_size_unshared_data_area_kb{$LABELS} %D
# HELP ${NAME}_process_avg_size_unshared_stack_space_kb Average size of the process's unshared stack space, in Kbytes.
# TYPE ${NAME}_process_avg_size_unshared_stack_space_kb gauge
${NAME}_process_avg_size_unshared_stack_space_kb{$LABELS} %p
# HELP ${NAME}_process_avg_size_shared_text_space_kb Average size of the process's shared text space, in Kbytes.
# TYPE ${NAME}_process_avg_size_shared_text_space_kb gauge
${NAME}_process_avg_size_shared_text_space_kb{$LABELS} %X
# HELP ${NAME}_major_page_fault_count Number of major page faults that occurred while the process was running. These are faults where the page has to be read in from disk.
# TYPE ${NAME}_major_page_fault_count gauge
${NAME}_major_page_fault_count{$LABELS} %F
# HELP ${NAME}_minor_page_fault_count Number of minor, or recoverable, page faults. These are faults for pages that are not valid but which have not yet been claimed by other virtual pages. Thus the data in the page is still valid but the system tables must be updated.
# TYPE ${NAME}_minor_page_fault_count gauge
${NAME}_minor_page_fault_count{$LABELS} %R
# HELP ${NAME}_command Name and command-line arguments of the command being timed. See Label.
# TYPE ${NAME}_command gauge
${NAME}_command{$LABELS,command=\"%C\"} 1"

$GNU_TIME_COMMAND --append --output="${TEXTFILE_PATH}.tmp" --format="$TIME_FORMAT" ${@:$OPTIND}
EXIT=$?
printf "# HELP ${NAME}_endtime Start time in Unix time with microseconds.
# TYPE ${NAME}_endtime gauge
${NAME}_endtime{$LABELS} $(date +%s%3N)\n" >> ${TEXTFILE_PATH}.tmp

if [ -n "$VERBOSE" ] ; then
    cat ${TEXTFILE_PATH}.tmp
fi

# Copy contents of temporary file to permanent path
cp -p "${TEXTFILE_PATH}.tmp" "$TEXTFILE_PATH"

# Return same exit signal of subprocess
exit $EXIT
